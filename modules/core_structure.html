

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Core structure &mdash; pySC 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=988d0652" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=938c9ccc"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Correction algorithms" href="correction.html" />
    <link rel="prev" title="Core functions" href="core_functions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/pySC_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core_functions.html">Core functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core_functions.html#beam">Beam</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_functions.html#pySC.core.beam.all_elements_reading"><code class="docutils literal notranslate"><span class="pre">all_elements_reading()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="core_functions.html#pySC.core.beam.beam_transmission"><code class="docutils literal notranslate"><span class="pre">beam_transmission()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="core_functions.html#pySC.core.beam.bpm_reading"><code class="docutils literal notranslate"><span class="pre">bpm_reading()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="core_functions.html#pySC.core.beam.generate_bunches"><code class="docutils literal notranslate"><span class="pre">generate_bunches()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="core_functions.html#lattice-setting">Lattice setting</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_functions.html#pySC.core.lattice_setting.switch_cavity_and_radiation"><code class="docutils literal notranslate"><span class="pre">switch_cavity_and_radiation()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Core structure</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simulated-commissioning">Simulated Commissioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pySC.core.simulated_commissioning.SimulatedCommissioning"><code class="docutils literal notranslate"><span class="pre">SimulatedCommissioning</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#subclasses">Subclasses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pySC.core.classes.DotDict"><code class="docutils literal notranslate"><span class="pre">DotDict</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pySC.core.classes.Indices"><code class="docutils literal notranslate"><span class="pre">Indices</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pySC.core.classes.Injection"><code class="docutils literal notranslate"><span class="pre">Injection</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pySC.core.classes.Sigmas"><code class="docutils literal notranslate"><span class="pre">Sigmas</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="correction.html">Correction algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="correction.html#trajectory-and-orbit">Trajectory and Orbit</a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#pySC.correction.orbit_trajectory.balance"><code class="docutils literal notranslate"><span class="pre">balance()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#pySC.correction.orbit_trajectory.correct"><code class="docutils literal notranslate"><span class="pre">correct()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#pySC.correction.orbit_trajectory.first_turn"><code class="docutils literal notranslate"><span class="pre">first_turn()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#pySC.correction.orbit_trajectory.stitch"><code class="docutils literal notranslate"><span class="pre">stitch()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#rf">RF</a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#pySC.correction.rf.phase_and_energy_error"><code class="docutils literal notranslate"><span class="pre">phase_and_energy_error()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#tune">Tune</a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#pySC.correction.tune.tune_scan"><code class="docutils literal notranslate"><span class="pre">tune_scan()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#chromaticity">Chromaticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="correction.html#pySC.correction.chroma.fit_chroma"><code class="docutils literal notranslate"><span class="pre">fit_chroma()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lattice_properties.html">Lattice properties</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lattice_properties.html#pySC.lattice_properties.response_model.SCgetModelDispersion"><code class="docutils literal notranslate"><span class="pre">SCgetModelDispersion()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="lattice_properties.html#pySC.lattice_properties.response_model.SCgetModelRING"><code class="docutils literal notranslate"><span class="pre">SCgetModelRING()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="lattice_properties.html#pySC.lattice_properties.response_model.SCgetModelRM"><code class="docutils literal notranslate"><span class="pre">SCgetModelRM()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">Logging</a><ul>
<li class="toctree-l2"><a class="reference internal" href="logging.html#pySC.utils.logging_tools.DebugMode"><code class="docutils literal notranslate"><span class="pre">DebugMode</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="logging.html#pySC.utils.logging_tools.MaxFilter"><code class="docutils literal notranslate"><span class="pre">MaxFilter</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="logging.html#pySC.utils.logging_tools.file_handler"><code class="docutils literal notranslate"><span class="pre">file_handler()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="logging.html#pySC.utils.logging_tools.get_logger"><code class="docutils literal notranslate"><span class="pre">get_logger()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="logging.html#pySC.utils.logging_tools.stream_handler"><code class="docutils literal notranslate"><span class="pre">stream_handler()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="utils.html#at-wrapper">AT wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#pySC.utils.sc_tools.ords_from_regex"><code class="docutils literal notranslate"><span class="pre">ords_from_regex()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#pySC.utils.sc_tools.pinv"><code class="docutils literal notranslate"><span class="pre">pinv()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#pySC.utils.sc_tools.randnc"><code class="docutils literal notranslate"><span class="pre">randnc()</span></code></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pySC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Core structure</li>
      <li class="wy-breadcrumbs-aside">
              <!-- User defined GitHub URL -->
              <a href="https://github.com/lmalina/pySC" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pySC.core.simulated_commissioning">
<span id="core-structure"></span><h1>Core structure<a class="headerlink" href="#module-pySC.core.simulated_commissioning" title="Link to this heading"></a></h1>
<section id="simulated-commissioning">
<h2>Simulated Commissioning<a class="headerlink" href="#simulated-commissioning" title="Link to this heading"></a></h2>
<p>This module contains the main data structure of <code class="docutils literal notranslate"><span class="pre">pySC</span></code> package
built up around the <code class="docutils literal notranslate"><span class="pre">at.Lattice</span></code> under study.</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pySC.core.simulated_commissioning.</span></span><span class="sig-name descname"><span class="pre">SimulatedCommissioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Lattice</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning" title="Link to this definition"></a></dt>
<dd><p>The main structure of <code class="docutils literal notranslate"><span class="pre">pySC</span></code>, which holds all the information about
lattice error sources and errors, injection settings and its errors.
The class is initialized from <code class="docutils literal notranslate"><span class="pre">at.Lattice</span></code>.</p>
<p>SC.register* functions assign uncertainties
SC.apply_errors functions apply those sigmas to specific elements in the lattice
SC.update* functions transfer the information to the AT elements fields</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">at</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SC</span> <span class="o">=</span> <span class="n">SimulatedCommissioning</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">Lattice</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">Monitor</span><span class="p">(</span><span class="s1">&#39;BPM&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SC</span><span class="o">.</span><span class="n">register_bpms</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Offset</span><span class="o">=</span><span class="mf">2e-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">ORD</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">SIG</span><span class="o">.</span><span class="n">BPM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Offset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SC</span><span class="o">.</span><span class="n">apply_errors</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>The properties of the class are:</dt><dd><dl class="simple">
<dt>RING:</dt><dd><p>the AT ring lattice to which the errors will be added</p>
</dd>
<dt>IDEALRING:</dt><dd><p>the ideal AT ring lattice</p>
</dd>
<dt>INJ:</dt><dd><p>Class for definition of injection properties.
See Also <em>pySC.core.classes.Injection</em></p>
</dd>
<dt>SIG:</dt><dd><p>Class to store the error sigma’s.
This parameter is set via <em>register_magnets</em>, <em>register_bpms</em>, <em>register_cavities</em>, <em>register_supports</em>
See Also <em>pySC.core.classes.Sigmas</em></p>
</dd>
<dt>ORD:</dt><dd><p>Class to store the indices of registered elements in the lattice
This parameter is set via <em>register_magnets</em>, <em>register_bpms</em>, <em>register_cavities</em>, <em>register_supports</em>
See Also <em>pySC.core.classes.Indices</em></p>
</dd>
<dt>plot:</dt><dd><p>(default=False) a boolean flag to trigger plots</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.apply_errors">
<span class="sig-name descname"><span class="pre">apply_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsigmas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.apply_errors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.apply_errors" title="Link to this definition"></a></dt>
<dd><p>Applies errors to cavities, injection trajectory, BPMs, circumference,
support structures and magnets if the corresponding uncertainties defined in
<cite>SC.SIG</cite> are set. For example, for a magnet with ordinate <cite>ord</cite> every field
defined in <cite>SC.SIG.Mag{ord}</cite> will be used to generate a random number using a
Gaussian distribution with a cutoff (see option below) and <cite>sigma</cite> being the
value of the uncertainty field. The number will be stored in the
corresponding field of the lattice structure, thus <cite>SC.RING{ord}</cite>. An
exeption are bending angle errors which are stored in the <cite>BendingAngleError</cite>
field. See examples in the SC.register* functions for more details.</p>
<p><em>SC.apply_errors</em> uses the uncertainties defined in <cite>SC.SIG</cite> to
generate random errors and applies them to the corresponding attributes of elements in <cite>SC.RING</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nsigmas</strong> -- Number of sigmas at which the Gaussian distribution of errors is truncated</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.register_magnets</em>, <em>SC.register_support</em>, <em>SC.register_bpms</em>, <em>SC.register_cavities</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.get_cm_setpoints">
<span class="sig-name descname"><span class="pre">get_cm_setpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skewness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.get_cm_setpoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.get_cm_setpoints" title="Link to this definition"></a></dt>
<dd><p>Return current dipole Corrector Magnets (CM) setpoints</p>
<p>Reads the setpoints of the CMs specified in <cite>ords</cite> in the dimension <cite>skewness</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ords</strong> -- Array of CM ordinates in the lattice structure (ex: SC.ORD.CM[0])</p></li>
<li><p><strong>skewness</strong> -- boolean specifying CM dimension ([False|True] -&gt; [hor|ver])</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>CM setpoints [rad]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.register_bpms">
<span class="sig-name descname"><span class="pre">register_bpms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.register_bpms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.register_bpms" title="Link to this definition"></a></dt>
<dd><p>registers BPMs specified by the <cite>ords</cite> (element indices in the lattice) in the <cite>SC</cite> class instance
and initializes all required fields in the lattice elements. The ordinates of all registered BPMs are stored in
<cite>SC.ORD.BPM</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ords</strong> -- BPM ordinates in the lattice structure.</p>
</dd>
</dl>
<dl class="simple">
<dt>The BPM fields in the lattice elements are:</dt><dd><dl class="simple">
<dt>Noise:</dt><dd><p>2 elements array of hor./ver. turn-by-turn BPM noise uncertainties (sigmas)</p>
</dd>
<dt>NoiseCO:</dt><dd><p>2 elements array of hor./ver. orbit BPM noise uncertainties (sigmas)</p>
</dd>
<dt>CalError:</dt><dd><p>2 elements array of hor./ver. BPM calibration errors uncertainties (sigmas)</p>
</dd>
<dt>Offset:</dt><dd><p>2 elements array of individual hor./ver. BPM offsets uncertainties (sigmas)</p>
</dd>
<dt>Roll:</dt><dd><p>BPM roll around z-axis w.r.t. the support structure</p>
</dd>
<dt>SumError:</dt><dd><p>Calibration error of the sum signal. The sum signal is used to determine
the beam loss location with a cutoff as defined <cite>SC.INJ.beamLostAt</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Identify the ordinates of all elements named <cite>BPM</cite> and registers them as BPMs in <cite>SC</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ords</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;BPM&#39;</span><span class="p">)</span>
<span class="n">SC</span><span class="o">.</span><span class="n">register_bpms</span><span class="p">(</span><span class="n">ords</span><span class="p">)</span>
</pre></div>
</div>
<p>Register the BPMs specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of the offset to <cite>500um</cite> in
both planes. A subsequent call of <em>SC.apply_errors</em> would generate a random BPM offset errors with
<cite>sigma=500um</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_bpms</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="mf">500E-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Register the BPMs specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of the offset to <cite>500um</cite> in
both planes. A subsequent call of <em>SC.apply_errors</em> would generate a random BPM offset errors with
<cite>sigma=500um</cite> and a cutoff at 3 sigmas for this error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_bpms</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="p">[</span><span class="mf">500E-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Register the BPMs specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of the offset to <cite>500um</cite> in
both planes and a calibration error of the sum signal of 20%:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_bpms</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="mf">500E-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">SumError</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>bpm_reading</em>, <em>ords_from_regex</em>, <em>SC.verify_structure</em>, <em>SC.apply_errors</em>, <em>SC.register_support</em>, <em>SC.update_support</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.register_cavities">
<span class="sig-name descname"><span class="pre">register_cavities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.register_cavities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.register_cavities" title="Link to this definition"></a></dt>
<dd><p>Register cavities specified in <cite>ords</cite> in <cite>SC</cite> by initializing all required fields in the
corresponding cavity lattice elements and storing the ordinates in <cite>SC.ORD.RF</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ords</strong> -- Cavity ordinates in the lattice structure.</p>
</dd>
<dt class="field-even">Keyword Arguments<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>VoltageOffset</strong> -- Offset of cavity voltage wrt. to the setpoint</p></li>
<li><p><strong>VoltageCalError</strong> -- Calibration error of cavity voltage wrt. to the setpoint</p></li>
<li><p><strong>FrequencyOffset</strong> -- Offset of cavity frequency wrt. to the setpoint</p></li>
<li><p><strong>FrequencyCalError</strong> -- Calibration error of cavity frequency wrt. to the setpoint</p></li>
<li><p><strong>TimeLagOffset</strong> -- Offset of cavity phase wrt. to the setpoint</p></li>
<li><p><strong>TimeLagCalError</strong> -- Calibration error of cavity phase wrt. to the setpoint</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Identify the ordinates of all elements named <cite>‘CAV’</cite> and register them as cavities in <cite>SC</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ords</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span> <span class="s1">&#39;CAV&#39;</span><span class="p">)</span>
<span class="n">SC</span><span class="o">.</span><span class="n">register_cavities</span><span class="p">(</span><span class="n">ords</span><span class="p">)</span>
</pre></div>
</div>
<p>Register the cavities specified in <cite>ords</cite> in <cite>SC</cite> and sets the uncertainty of the frequency offset
to 1kHz. A subsequent call of <em>SC.apply_errors</em> would generate a random frequency offset error with <cite>sigma=1kHz</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_cavities</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">FrequencyOffset</span><span class="o">=</span><span class="mf">1E3</span><span class="p">)</span>
</pre></div>
</div>
<p>Register the cavities specified in <cite>ords</cite> in <cite>SC</cite> and sets the uncertainty of the frequency offset
to 1kHz. A subsequent call of <em>SC.apply_errors</em> would generate a random frequency offset error with
<cite>sigma=1kHz</cite> and a random timelag offset error (‘phase error’) with <cite>sigma=0.3m</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_cavities</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">FrequencyOffset</span><span class="o">=</span><span class="mf">1E3</span><span class="p">,</span> <span class="n">TimeLagOffset</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>ords_from_regex</em>, <em>SC.verify_structure</em>, <em>SC.apply_errors</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.register_magnets">
<span class="sig-name descname"><span class="pre">register_magnets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.register_magnets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.register_magnets" title="Link to this definition"></a></dt>
<dd><p>Registers magnets specified by <cite>ords</cite> in the <cite>SC</cite> structure and initializes all required fields
in the lattice elements. The ordinates of all registered magnets are stored in <cite>SC.ORD.Magnet</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ords</strong> -- Magnet ordinates in the lattice structure.</p>
</dd>
<dt class="field-even">Keyword Arguments<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>CalErrorB</strong> -- Calibration error of the <cite>PolynomB</cite> fields wrt. the corresponding setpoints.
Each element of the numpy.array is the error for the corresponding element in ‘PolynomB’</p></li>
<li><p><strong>CalErrorA</strong> -- Calibration error of the <cite>PolynomA</cite> fields wrt. the corresponding setpoints.
Each element of the numpy.array is the error for the corresponding element in ‘PolynomA’</p></li>
<li><p><strong>MagnetOffset</strong> -- 3 element array of horizontal, vertical and longitudinal magnet offsets (wrt. the support structure).</p></li>
<li><p><strong>MagnetRoll</strong> -- 3 element array [az,ax,ay] defineing magnet roll (around z-axis), pitch (roll around x-axis) and yaw (roll around
y-axis); all wrt. the support structure.</p></li>
<li><p><strong>BendingAngleError</strong> -- Error of the main bending field (corresponding uncertainty defined with <cite>BendingAngle</cite>).</p></li>
<li><p><strong>CF</strong> -- Flag identifying the corresponding magnet as a combined function dipole/quadrupole. That implies that the
bending angle depends on the quadrupole setpoint. A variation from the design value will therefore result in a
bending angle error which is added to the <cite>PolynomB[0]</cite> field.</p></li>
<li><p><strong>HCM</strong> -- Flag identifying the corresponding magnet as a horizontal corrector magnet. The corresponding value is the
horizontal CM limit and stored in <cite>SC.RING[ords].CMlimit[0]</cite>. E.g. set limit to <cite>Inf</cite>.</p></li>
<li><p><strong>VCM</strong> -- Flag identifying the corresponding magnet as a vertical corrector magnet. The corresponding value is the
vertical CM limit and stored in <cite>SC.RING[ords].CMlimit[1]</cite>. E.g. set limit to <cite>Inf</cite>.</p></li>
<li><p><strong>SkewQuad</strong> -- Flag identifying the corresponding magnet as a skew quadrupole corrector magnet. The corresponding value
is the skew quadrupole limit and stored in <cite>SC.RING[ords].SkewLimit</cite>. E.g. set limit to <cite>Inf</cite>.</p></li>
<li><p><strong>MasterOf</strong> -- Array of ordinates to which the corresponding magnet acts as master (split magnets).
The magnets at ordinates <cite>ords</cite> are identified as a split magnets each with <cite>N</cite> childs as specified in
the corresponding value which must be a [<cite>N</cite> x <cite>length(ords)</cite>] array.
The field calculation in <em>SC.update_magnets</em> uses the setpoints and errors of the master magnet to
calculate the child fields.
The relative bending angle error of the master magnet e.g. is applied
on the corresponding child bending angle appropriately.
Split quadrupole magnets with different design gradients, however, can
currently not be updated correctly.</p></li>
</ul>
</dd>
</dl>
<p>If CMs or skew quadrupole correctors are specified, the ordinates are also
stored in the corresponding fields <cite>SC.ORD.CM</cite> and <cite>SC.ORD.SkewQuad</cite>, respectively.</p>
<p class="rubric">Examples</p>
<p>Identify the ordinates of all elements named <cite>QF</cite> and register them in <cite>SC</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ords</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span> <span class="s1">&#39;QF&#39;</span><span class="p">)</span>
<span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">)</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of
the quadrupole component to 1E-3 and 30um horizontal and vertical offset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span>
                    <span class="n">CalErrorB</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1E-3</span><span class="p">]),</span>
                    <span class="n">MagnetOffset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">30E-6</span><span class="p">,</span> <span class="mf">30E-6</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of
the quadrupole component to 1E-3, 30um horizontal and vertical offset and
100um longitudinal offset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span>
                    <span class="n">CalErrorB</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1E-3</span><span class="p">]),</span>
                    <span class="n">MagnetOffset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">30E-6</span><span class="p">,</span> <span class="mf">30E-6</span><span class="p">,</span> <span class="mf">100E-6</span><span class="p">]))</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of
the roll, pitch and yaw angle to 100urad:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">Roll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">100E-6</span><span class="p">,</span> <span class="mf">100E-6</span><span class="p">,</span> <span class="mf">100E-6</span><span class="p">]))</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of
the roll, pitch and yaw angle to 100urad and 3.4 sigmas cutoff:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">Roll</span><span class="o">=</span><span class="p">[</span><span class="mf">100E-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">3.4</span><span class="p">])</span>
</pre></div>
</div>
<p>Register split magnets.
Identify the magnets named <cite>BENDa</cite> ([<cite>1xN</cite>] array <cite>masterOrds</cite>) and the
magnets named <cite>BENDb</cite> and <cite>BENDc</cite> ([<cite>2xN</cite>] array <cite>childOrds</cite>) and register
the <cite>masterOrds</cite> as the master magnets of the children in the corresponding
columns of <cite>childOrds</cite>.
The uncertainty of the bending angle is set to 1E-4:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">masterOrds</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;BENDa&#39;</span><span class="p">)</span>
<span class="n">childOrds</span>  <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;BENDb&#39;</span><span class="p">),</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;BENDc&#39;</span><span class="p">)))</span>
<span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">masterOrds</span><span class="p">,</span> <span class="n">BendingAngle</span><span class="o">=</span><span class="mf">1E-4</span><span class="p">,</span> <span class="n">MasterOf</span><span class="o">=</span><span class="n">childOrds</span><span class="p">)</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> as combined function magnets
and sets the uncertainty of the quadrupole component to 1E-3:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">CF</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">CalErrorB</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1E-3</span><span class="p">]))</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> and set the uncertainty of
the skew quadrupole component to 2E-3 and the uncertainty of the sextupole
component to 1E-3:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">CalErrorA</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2E-3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">CalErrorB</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1E-3</span><span class="p">]))</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> as horizontal and vertical
CMs, set their dipole uncertainties to 5% and 1%, respectively and define no CM limits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">HCM</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">VCM</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">CalErrorB</span><span class="o">=</span><span class="mf">5E-2</span><span class="p">,</span> <span class="n">CalErrorA</span><span class="o">=</span><span class="mf">1E-2</span><span class="p">)</span>
</pre></div>
</div>
<p>Register the magnets specified in <cite>ords</cite> in <cite>SC</cite> as horizontal and vertical
CMs, set their uncertainties to 5% and 1%, respectively and their limits to 1
mrad. Furthermore, set the uncertainty of the skew quadrupole component to
2E-3 and the uncertainty of the sextupole component to 1E-3:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span>
                    <span class="n">HCM</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>
                    <span class="n">VCM</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>
                    <span class="n">CalErrorB</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">5E-2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1E-3</span><span class="p">]),</span>
                    <span class="n">CalErrorA</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1E-2</span><span class="p">,</span> <span class="mf">2E-3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>ords_from_regex</em>, <em>SC.update_magnets</em>, <em>SC.verify_structure</em>, <em>SC.apply_errors</em>, <em>SC.register_support</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.register_supports">
<span class="sig-name descname"><span class="pre">register_supports</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">support_ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">support_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.register_supports"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.register_supports" title="Link to this definition"></a></dt>
<dd><p>Initializes magnet support structures such as sections, plinths and girders in SC. The function
input be given as name-value pairs, starting with the structure type and structure ordinates
defining start-end endpoints. Optional arguments are set as the uncertainties of e.g. girder
offsets in the sigma structure <cite>SC.SIG.Support</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>support_ords</strong> -- [2xN] array of ordinates defining start and end locations of <cite>N</cite> registered support structures</p></li>
<li><p><strong>support_type</strong> -- String specifying the support structure type. Valid are ‘Plinth’, ‘Girder’ or ‘Section’</p></li>
<li><p><strong>**kwargs</strong> -- any of those listed below</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>Offset</strong> -- A [1x3] array defining horizontal, vertical and longitudinal offset uncertainties for the start
points or [2x3] array defining horizontal, vertical and longitudinal offset uncertainties for
the start end endpoints. If end points have dedicated uncertainties, <em>SC.apply_errors</em> applies
random offset errors of both start end endpoints of the corresponding support structure,
effectively tilting the support structure.
If only start points have asigned uncertainties, <em>SC.apply_errors</em> applies to the support
structure endpoints the same offset error as to the start points, resulting in a paraxial
translation of the element. Only in this case dedicated <cite>‘Roll’</cite> uncertainties may be given which
then tilt the structure around it’s center.
The actual magnet or BPM offsets resulting from the support structure offsets is calculated in
<em>SC.update_support</em> by interpolating on a straight line between girder start- and endpoints. Note
that the coordinate system change due to bending magnets are ignored in this calculation. Thus,
the accuracy of the result is limited if dipole magnets are involved. This may be particularly
true in case of large sections and/or longitudinal offsets.</p></li>
<li><p><strong>Roll</strong> -- [1x3] array [az,ax,ay] defining roll (around z-axis), pitch (roll around x-axis) and yaw (roll
around y-axis) angle uncertainties.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Registers the girder start end endpoints defined in <cite>ords</cite> and assigns the horizontal,
vertical and longitudinal girder offset uncertainties <cite>dX</cite>, <cite>dY</cite> and <cite>dZ</cite>, respectively, to the
girder start points. When the support errors are applied the girder endpoints will get the same
offset error as the start points, resulting in a paraxial translation of the girder:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_support</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="s2">&quot;Girder&quot;</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="p">[</span><span class="n">dX</span><span class="p">,</span> <span class="n">dY</span><span class="p">,</span> <span class="n">dZ</span><span class="p">])</span>
</pre></div>
</div>
<p>Registers the section start- end endpoints defined in <cite>ords</cite> and assigns the horizontal and
vertical section offset uncertainties <cite>dX</cite> and <cite>dY</cite>, respectively, to the start points. When
the support errors are applied the section endpoints will get the same offset as the start points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_support</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="s2">&quot;Section&quot;</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dX</span><span class="p">,</span> <span class="n">dY</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>Registers the section start- end endpoints defined in <cite>ords</cite> and assigns the horizontal and
vertical section offset uncertainties <cite>dX</cite> and <cite>dY</cite>, respectively, to the start points. When
the support errors are applied the section endpoints will get the same offset as the start points.
Also set a 4.2 sigmas cutoff:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_support</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="s2">&quot;Section&quot;</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dX</span><span class="p">,</span> <span class="n">dY</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mf">4.2</span><span class="p">])</span>
</pre></div>
</div>
<p>Registers the girder start end endpoints defined in <cite>ords</cite>, assigns the roll uncertainty <cite>dPhi</cite>
and the horizontal and vertical girder offset uncertainties <cite>dX1</cite> and <cite>dY1</cite>, respectively to the
start points and <cite>dX2</cite> and <cite>dY2</cite> to the endpoints. When the support errors are applied, all
girder start- and endpoints will get random offset errors and the resulting yaw and pitch angles
are calculated accordingly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_support</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="s2">&quot;Girder&quot;</span><span class="p">,</span>
                    <span class="n">Offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dX1</span><span class="p">,</span> <span class="n">dY1</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dX2</span><span class="p">,</span> <span class="n">dY2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                    <span class="n">Roll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dPhi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>Registers the girder start end endpoints defined in <cite>ords</cite> and assigns the horizontal,
vertical and longitudinal girder offset uncertainties <cite>dX</cite>, <cite>dY</cite> and <cite>dZ</cite>, respectively, and the
roll, pitch and yaw angle uncertainties <cite>az</cite>, <cite>ax</cite> and <cite>ay</cite>. When the support errors are applied
the girders will experience a paraxial translation according to the offsets plus the proper
rotations around the three x-, y- and z-axes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">register_support</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="s2">&quot;Girder&quot;</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dX</span> <span class="n">dY</span> <span class="n">dZ</span><span class="p">]),</span> <span class="n">Roll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">az</span> <span class="n">ax</span> <span class="n">ay</span><span class="p">]));</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>ords_from_regex</em>, <em>SC.update_support</em>, <em>SC.support_offset_and_roll</em>, <em>plot_support</em>, <em>SC.apply_errors</em>,
<em>SC.register_magnets</em>, <em>update_transformation</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.set_cavity_setpoints">
<span class="sig-name descname"><span class="pre">set_cavity_setpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setpoints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'abs'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.set_cavity_setpoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.set_cavity_setpoints" title="Link to this definition"></a></dt>
<dd><p>Set RF properties to setpoints</p>
<p>Set the setpoints of <cite>Voltage</cite>, <cite>Frequency</cite> or <cite>TimeLag</cite> as specified in “param” of the rf
cavities specified in <cite>ords</cite>. If only a single setpoint is given for multiple cavities,
the setpoint is applied to all cavities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ords</strong> -- Array of cavity ordinates in the lattice structure (SC.ORD.RF)</p></li>
<li><p><strong>setpoints</strong> -- Setpoints (array or single value for all cavities)</p></li>
<li><p><strong>param</strong> -- String (‘Voltage’, ‘Frequency’ or ‘TimeLag’) specifying which cavity field should be set.</p></li>
<li><p><strong>method</strong> -- ‘abs’ (default), Use absolute setpoint
‘rel’, Use relative setpoint to nominal value
‘add’, Add setpoints to current value</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Sets the time lag of all cavities registered in SC to zero:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">set_cavity_setpoints</span><span class="p">(</span><span class="n">ords</span><span class="o">=</span><span class="n">SC</span><span class="o">.</span><span class="n">ORD</span><span class="o">.</span><span class="n">RF</span><span class="p">,</span> <span class="n">setpoints</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;TimeLag&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Adds 1kHz to the frequency of the first cavity:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">set_cavity_setpoints</span><span class="p">(</span><span class="n">ords</span><span class="o">=</span><span class="n">SC</span><span class="o">.</span><span class="n">ORD</span><span class="o">.</span><span class="n">RF</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">setpoints</span><span class="o">=</span><span class="mf">1E3</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;Frequency&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.set_cm_setpoints">
<span class="sig-name descname"><span class="pre">set_cm_setpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setpoints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skewness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'abs'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.set_cm_setpoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.set_cm_setpoints" title="Link to this definition"></a></dt>
<dd><p>Sets dipole corrector magnets to different setpoints</p>
<p>Sets horizontal or vertical CMs as specified in <cite>ords</cite> and <cite>skewness</cite>, respectively, to <cite>setpoints</cite>
[rad] and updates the magnetic fields. If the corresponding setpoint exceeds the CM limit
specified in the corresponding lattice field <cite>CMlimit</cite>, the CM is clipped to that value
and a warning is being printed (to switch off, use <cite>warning(‘off’,’SC:CM1’))</cite>. Positive setpoints
will result in kicks in the positive horizontal or vertical direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ords</strong> -- Array of CM ordinates in the lattice structure (ex: SC.ORD.CM[0])</p></li>
<li><p><strong>setpoints</strong> -- CM setpoints (array or single value for all CMs) [rad]</p></li>
<li><p><strong>skewness</strong> -- boolean specifying CM dimension ([False|True] -&gt; [hor|ver])</p></li>
<li><p><strong>method</strong> -- ‘abs’ (default), Use absolute setpoint
‘rel’, Use relative setpoint to current value
‘add’, Add setpoints to current value</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Set all registered horizontal CMs to zero:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">set_cm_setpoints</span><span class="p">(</span><span class="n">ords</span><span class="o">=</span><span class="n">SC</span><span class="o">.</span><span class="n">ORD</span><span class="o">.</span><span class="n">HCM</span><span class="p">,</span> <span class="n">skewness</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">setpoints</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Add 10urad to the fourth registered vertical CM:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">set_cm_setpoints</span><span class="p">(</span><span class="n">ords</span><span class="o">=</span><span class="n">SC</span><span class="o">.</span><span class="n">ORD</span><span class="o">.</span><span class="n">VCM</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">setpoints</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span> <span class="n">skewness</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.set_magnet_setpoints">
<span class="sig-name descname"><span class="pre">set_magnet_setpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setpoints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skewness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'abs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_compensation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.set_magnet_setpoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.set_magnet_setpoints" title="Link to this definition"></a></dt>
<dd><p>Sets magnets to setpoints</p>
<p>Sets magnets (except CMs) as specified in <cite>ords</cite> to <cite>setpoints</cite> while <cite>order</cite> and <cite>skewness</cite> defines
which field entry should be used (see below). The setpoints may be given relative to their nominal
value or in absolute terms. If the considered quadrupole is a combined function magnet with
non-zero bending angle and the kick compensation flag ‘dipole_compensation’=True, the appropriate bending
angle difference is calculated and the horizontal CM setpoint is changed accordingly to compensate
for that dipole kick difference.
If the setpoint of a skew quadrupole exceeds the limit specified in the corresponding lattice
field <cite>SkewQuadLimit</cite>, the setpoint is clipped to that value and a warning is logged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ords</strong> -- Array of magnets ordinates in the lattice structure (ex: SC.ORD.HCM) (numpy.array() or list of int [int,int,..])</p></li>
<li><p><strong>setpoints</strong> -- magnets setpoints (array or single value for all magnets).
setpoints are assigned to the given order and skewness, i.e. once updated through
SimulatedCommissioning.apply_errors, they correspond to a single element of PolynomA or PolynomB</p></li>
<li><p><strong>skewness</strong> -- boolean specifying magnet plane ([False|True] -&gt; [PolynomB|PolynomA])</p></li>
<li><p><strong>method</strong> -- ‘abs’ (default), Use absolute setpoint
‘rel’, Use relative setpoint to nominal value
‘add’, Add setpoints to current value</p></li>
<li><p><strong>order</strong> -- Numeric value defining the order of the considered magnet: [0,1,2,…] =&gt; [dip,quad,sext,…]</p></li>
<li><p><strong>dipole_compensation</strong> -- (default = False) Used for combined function magnets. If this flag is set and if there is a horizontal CM
registered in the considered magnet, the CM is used to compensate the bending angle difference
if the applied quadrupole setpoints differs from the design value.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Identify the ordinates of all elements named <cite>‘SF’</cite> and switch their sextupole component off:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ords</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;SF&#39;</span><span class="p">)</span>
<span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">)</span>
<span class="n">SC</span><span class="o">.</span><span class="n">set_magnet_setpoints</span><span class="p">(</span><span class="n">ords</span><span class="o">=</span><span class="n">ords</span><span class="p">,</span> <span class="n">skewness</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">setpoints</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;abs&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Identify the ordinates of all elements named <cite>QF</cite> and <cite>QD</cite> and set their quadrupole component to 99% of their design value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ords</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;QF|QD&#39;</span><span class="p">)</span>
<span class="n">SC</span><span class="o">.</span><span class="n">register_magnets</span><span class="p">(</span><span class="n">ords</span><span class="p">)</span>
<span class="n">SC</span><span class="o">.</span><span class="n">set_magnet_setpoints</span><span class="p">(</span><span class="n">ords</span><span class="o">=</span><span class="n">ords</span><span class="p">,</span> <span class="n">skewness</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">setpoints</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rel&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.set_random_multipole_errors">
<span class="sig-name descname"><span class="pre">set_random_multipole_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BA</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.set_random_multipole_errors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.set_random_multipole_errors" title="Link to this definition"></a></dt>
<dd><p>Applies random multipole errors specified in <cite>BA</cite> in the lattice elements <cite>ords</cite> of <cite>RING</cite>.
It generates random multipole components with a 2-sigma truncated Gaussian distribution
from each of the <cite>BA</cite> entries.
The final multipole errors are stored in the PolynomA/BOffset of the lattice elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ords</strong> -- Ordinates of the considered magnets.</p></li>
<li><p><strong>BA</strong> -- [N x 2] array of PolynomB/A multipole errors. [normal, skew] components.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Defines random multipole components for the ‘QF’ magnet
and adds it to the field offsets of all magnets named ‘QF’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ords</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;QF&#39;</span><span class="p">)</span>
<span class="n">BA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1E-5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1E-4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1E-2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">SC</span><span class="o">.</span><span class="n">set_random_multipole_errors</span><span class="p">(</span><span class="n">ords</span><span class="p">,</span> <span class="n">BA</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.update_magnets</em>, <em>SC.set_systematic_multipole_errors</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.set_systematic_multipole_errors">
<span class="sig-name descname"><span class="pre">set_systematic_multipole_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skewness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.set_systematic_multipole_errors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.set_systematic_multipole_errors" title="Link to this definition"></a></dt>
<dd><p>Applies multipole errors specified in <cite>AB</cite> in the lattice elements <cite>ords</cite> of <cite>RING</cite> depending on
the specified options.
It sets the systematic multipoles of the field component defined by option <cite>‘order’</cite> and <cite>‘type’</cite>.
It is required that the <cite>BA</cite> entries are normalized by that component, e.g. <cite>BA[1, 0]=1</cite> for skew-quadrupole
systematic multipoles.
The systematic multipoles are from now on scaled with the current magnet excitation and added to the
PolynomA/B fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ords</strong> -- Ordinates of the considered magnets.</p></li>
<li><p><strong>BA</strong> -- [N x 2] array of PolynomA/B multipole errors.</p></li>
<li><p><strong>order</strong> -- Numeric value defining the order of the considered magnet: [0,1,2,…] =&gt; [dip,quad,sext,…]</p></li>
<li><p><strong>skewness</strong> -- if True apply errors to skew fields (PolynomA) if False to normal fields (PolynomB)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Defines systematic multipole components for the ‘QF’ magnet and
adds it to the field offsets of all magnets named ‘QF’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ords</span> <span class="o">=</span> <span class="n">sc_tools</span><span class="o">.</span><span class="n">ords_from_regex</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">RING</span><span class="p">,</span><span class="s1">&#39;QF&#39;</span><span class="p">)</span>
<span class="n">BA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1E-5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1E-4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1E-2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">RING</span> <span class="o">=</span> <span class="n">SC</span><span class="o">.</span><span class="n">set_systematic_multipole_errors</span><span class="p">(</span><span class="n">RING</span><span class="p">,</span> <span class="n">ords</span><span class="p">,</span> <span class="n">BA</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.update_magnets</em>, <em>SC.set_random_multipole_errors</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.support_offset_and_roll">
<span class="sig-name descname"><span class="pre">support_offset_and_roll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_locations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.support_offset_and_roll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.support_offset_and_roll" title="Link to this definition"></a></dt>
<dd><p>This function evaluates the total offsets, roll, pitch and yaw angles of the support structures that have
been defined via <em>SC.register_support</em> at the longitudinal positions <cite>s</cite> by linearly interpolating
between support structure start- and endpoints (girder + sections + plinths, if registered).
Note that this calculation may not provide the proper values if magnets with non-zero bending
angle are within the support structure because it does not account for the rotation of the
local coordinate system along the beam trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>s_locations</strong> -- Array of s-positions at which the offset is evaluated.</p>
</dd>
</dl>
<p>Return type:</p>
<blockquote>
<div><p>[3,length(s)]-array containing the [dx/dy/dz] total support structure offsets at <cite>s</cite>.</p>
<p>[3,length(s)]-array containing the [az/ax/ay] total support structure rolls at <cite>s</cite>.</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.register_support</em>, <em>SC.update_support</em>, <em>plot_support</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.update_cavities">
<span class="sig-name descname"><span class="pre">update_cavities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.update_cavities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.update_cavities" title="Link to this definition"></a></dt>
<dd><p>Updates the cavity fields <cite>Voltage</cite>, <cite>Frequency</cite> and <cite>TimeLag</cite> in <cite>SC.RING</cite> as specified in <cite>ords</cite>.
If no ordinates are given explicitly, all registered cavities defined in <cite>SC.ORD.RF</cite> are
updated. For each cavity and each field, the setpoints, calibration errors and offsets are considered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ords</strong> -- Cavity ordinates to be updated.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.register_cavities</em>, <em>SC.apply_errors</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.update_magnets">
<span class="sig-name descname"><span class="pre">update_magnets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.update_magnets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.update_magnets" title="Link to this definition"></a></dt>
<dd><p>Updates the magnets specified in <cite>RING</cite> as specified in <cite>ords</cite>. If no ordinates are given
explicitly, all registered magnets defined in <cite>SC.ORD.Magnet</cite> are updated. For each magnet the
setpoints (<cite>SetPointA/B</cite>) and calibration errors (<cite>CalErrorA/B</cite>) are evaluated.
If systematic multipole components are specified, e.g. in <cite>SysPolBFromB</cite> for systematic
PolynomB-multipoles induced by PolynomB entries, the corresponding multipole components are scaled
by the current magnet excitation and added, as well as static field offsets (if specified in
<cite>PolynomA/BOffset</cite>).
If the considered magnet has a bending angle error (from pure bending angle error or due to a
combined function magnet), the corresponding horizontal dipole magnetic field is calculated and
added to the PolynomB(1) term. It is thereby assured that a dipole error doesn’t alter the
coordinate system.
If the considered magnet is registered as a slpit magnet (<cite>‘MasterOf’</cite>), the errors and setpoints
of the master magnet are applied to the fields of the child magnets. Note that split quadrupole
magnets with different gradients, however, or split CMs can currently not be updated correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ords</strong> -- Magnets ordinates to be updated.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.register_magnets</em>, <em>SC.apply_errors</em>, <em>SC.set_systematic_multipole_errors</em>,
<em>SC.set_random_multipole_errors</em>, <em>set_magnet_setpoints</em>, <em>set_cm_setpoints</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.update_supports">
<span class="sig-name descname"><span class="pre">update_supports</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset_bpms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_magnets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.update_supports"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.update_supports" title="Link to this definition"></a></dt>
<dd><p>This function updates the offsets and rolls of the elements in <cite>SC.RING</cite>
based on the current support errors, by setting the lattice fields <cite>T1</cite>, <cite>T2</cite>, and
<cite>R1</cite>, <cite>R2</cite> for magnets and the fields <cite>SupportOffset</cite> and <cite>SupportRoll</cite> for BPMs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>offset_bpms</strong> -- If true, BPM offsets are updated.</p></li>
<li><p><strong>offset_magnets</strong> -- If true, magnet offsets are updated.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.register_support</em>, <em>SC.support_offset_and_roll</em>, <em>plot_support</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pySC.core.simulated_commissioning.SimulatedCommissioning.verify_structure">
<span class="sig-name descname"><span class="pre">verify_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/simulated_commissioning.html#SimulatedCommissioning.verify_structure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.simulated_commissioning.SimulatedCommissioning.verify_structure" title="Link to this definition"></a></dt>
<dd><p>Verifies the integrity of SimilatedCommissionining class instance and warns if things look fishy.
If you find something that is missing please contact us.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><em>SC.register_magnets</em>, <em>SC.register_bpms</em>, <em>SC.register_cavities</em></p>
</div>
</dd></dl>

</dd></dl>

<section id="subclasses">
<span id="module-pySC.core.classes"></span><h2>Subclasses<a class="headerlink" href="#subclasses" title="Link to this heading"></a></h2>
<p>This module contains the classes needed in the main data structure (<code class="docutils literal notranslate"><span class="pre">SimulatedCommissioning</span></code>).</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="pySC.core.classes.DotDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pySC.core.classes.</span></span><span class="sig-name descname"><span class="pre">DotDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pySC/core/classes.html#DotDict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.classes.DotDict" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pySC.core.classes.DotDict.deepcopy">
<span class="sig-name descname"><span class="pre">deepcopy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pySC.core.classes.DotDict" title="pySC.core.classes.DotDict"><span class="pre">DotDict</span></a></span></span><a class="reference internal" href="../_modules/pySC/core/classes.html#DotDict.deepcopy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.classes.DotDict.deepcopy" title="Link to this definition"></a></dt>
<dd><p>Returns a deep copy</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pySC.core.classes.Indices">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pySC.core.classes.</span></span><span class="sig-name descname"><span class="pre">Indices</span></span><a class="reference internal" href="../_modules/pySC/core/classes.html#Indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.classes.Indices" title="Link to this definition"></a></dt>
<dd><p>Indices of magnets, RF cavities, BPMs, correctors,  girders,  plinths and sections in the AT lattice</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BPM</strong> -- numpy.array of integers. index of beam position monitors</p></li>
<li><p><strong>RF</strong> -- numpy.array of integers. index of RF cavities</p></li>
<li><p><strong>Magnet</strong> -- numpy.array of integers. index of magnets</p></li>
<li><p><strong>SkewQuad</strong> -- numpy.array of integers. index of skew quadrupoles</p></li>
<li><p><strong>HCM</strong> -- numpy.array of integers. index of horizontal correctors</p></li>
<li><p><strong>VCM</strong> -- numpy.array of integers. index of vertical correctors</p></li>
<li><p><strong>Girder</strong> -- numpy.array of 2 element tuples. (start, end) start and end index of Girders</p></li>
<li><p><strong>Plinth</strong> -- numpy.array of 2 element tuples. (start, end) start and end index of Plinths</p></li>
<li><p><strong>Section</strong> -- numpy.array of 2 element tuples. (start, end) start and end index of Sections</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>get BPM indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">ORD</span><span class="o">.</span><span class="n">BPM</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pySC.core.classes.Injection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pySC.core.classes.</span></span><span class="sig-name descname"><span class="pre">Injection</span></span><a class="reference internal" href="../_modules/pySC/core/classes.html#Injection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.classes.Injection" title="Link to this definition"></a></dt>
<dd><p>Define injection parameters for “pySC”</p>
<dl class="simple">
<dt>properties of this class are:</dt><dd><dl class="simple">
<dt>beamLostAt:</dt><dd><p>(default=1) Relative amount of particles which may be lost before BPM reading is NaN</p>
</dd>
<dt>Z0ideal:</dt><dd><p>(default=numpy.zeros(6)) Design injected trajectory</p>
</dd>
<dt>Z0:</dt><dd><p>(default=numpy.zeros(6)) Injected trajectory</p>
</dd>
<dt>beamSize:</dt><dd><p>(default=numpy.zeros((6,6))) Injected bunch beam size</p>
</dd>
<dt>randomInjectionZ:</dt><dd><p>(default=numpy.zeros(6))  Injected beam random trajectory jitter</p>
</dd>
<dt>staticInjectionZ:</dt><dd><p>(default=numpy.zeros(6))  Injected beam static trajectory offset</p>
</dd>
<dt>nParticles:</dt><dd><p>(default=1) Number of particles per bunch</p>
</dd>
<dt>nTurns:</dt><dd><p>(default=1) Number of turns for tracking</p>
</dd>
<dt>nShots:</dt><dd><p>(default=1) Number of injections for averaging BPM reading</p>
</dd>
<dt>trackMode:</dt><dd><dl class="simple">
<dt>(default=’TBT’) Tracking mode can be one of:</dt><dd><p>TBT (Turn By Turn),
ORB (Closed Orbit),
PORB (pseudo Closed Orbit) turn-by-turn tracking with trajectories averaged over the turns</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pySC.core.classes.Sigmas">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pySC.core.classes.</span></span><span class="sig-name descname"><span class="pre">Sigmas</span></span><a class="reference internal" href="../_modules/pySC/core/classes.html#Sigmas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pySC.core.classes.Sigmas" title="Link to this definition"></a></dt>
<dd><p>Defined rms (sigma) size of errors later assigned to BPM, RF, magnets, supports and injection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BPM</strong> -- errors sigma’s in BPMs</p></li>
<li><p><strong>Magnet</strong> -- errors sigma’s in Magnets</p></li>
<li><p><strong>RF</strong> -- errors sigma’s in RF</p></li>
<li><p><strong>Support</strong> -- errors sigma’s in Supports</p></li>
<li><p><strong>randomInjectionZ</strong> -- numpy.array of 6 elements defining sigmas of random errors
for the input coordinates x, x’, y, y’, delta and ct</p></li>
<li><p><strong>staticInjectionZ</strong> -- numpy.array of 6 elements defining an offset
for the input coordinates x, x’, y, y’, delta and ct</p></li>
<li><p><strong>Circumference</strong> -- float. Circumference error</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>get BPM sigmas from SimualtedCommissioning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC</span><span class="o">.</span><span class="n">SIG</span><span class="o">.</span><span class="n">BPM</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="core_functions.html" class="btn btn-neutral float-left" title="Core functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="correction.html" class="btn btn-neutral float-right" title="Correction algorithms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>